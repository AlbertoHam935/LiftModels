# -*- coding: utf-8 -*-
"""CodigoSustentacion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V8jtaM-cZVOw3kAGp9wzeJIbtyBQINZl
"""

from re import X
import math
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn import datasets, linear_model
from pprint import pprint

#_______________________________________________________________________
#         Espacio para definir funciones
#__________________________________________________________________________

#Definimos la funcion de regresion lineal
def regresion (x,y):
  RegresorVP=linear_model.LinearRegression()
  X=np.array(x).reshape(-1,1)
  Y=np.array(y).reshape(-1,1)

  Regresor=linear_model.LinearRegression()
  Regresor.fit(X,Y)
  Predict=Regresor.predict(X)

  m=Regresor.coef_[0][0]
  b=Regresor.intercept_[0]


  return m,b

#Definimos la funcion para la obtencion de los coeficientes

def Fij (b,c,n,m_curve,phi_r,ai):

  #Obtenemos los datos de la matriz de coeficientes
  for j in range(1,n+1):
    renglon=[]
    for i in phi_r:

      aux=(((4*b)/(m_curve*c))+((j)/(math.sin(i))))*(math.sin(j*i))
      #Metemos el dato auxiliar a una lista de renglones
      renglon.append(aux)
    #Cragamos el renglo a la matriz para que sea una fila.
    ai.append(renglon)
  return




#________________________________________________________________________________
#             Seccion de codigo principal.
#_______________________________________________________________________________

#____________________LISTAS DE APOYO_____________________________________________

AoA=[]              #Lista de angulos de ataque en grados
Rad_AoA=[]          #Lista de apoyo de angulos de ataque a radianes
cl_list=[]          #Lista de los coeficientes de sustentacion a diferentes AoA
ai=[]               #Lista de los coeficientes de para apoyo de los AJ
aj=[]               #Lista de los Coeficientes finales
V_ind=[]            #Listas de terminos independientes
Aj=[]               #Coeficientes de solucion del modelo.
L_distribution=[]   #Distribucion de sustentacion

Env_dis=[]      #Valores de envergadura discretizada

phi=[]         #Angulos de la discretizacion
phi_rad=[]     #Angulos de discretizacion en radianes


#Nombramos y asignamos un data frame con los valores del archivo del perfil omitiendo las
#Primeras 10 filas
df = pd.read_csv('/content/xf_n2415.csv', skiprows=10)
#print(df)

#Asignamos los headers de cada una de las columnas de informacion.
df.columns = ["AoA", "Cl", "cd", "cdp", "cm", "Top_xtr", "Bot_xtr"]
#print(df["AoA"])

#Ploteamos la curva solo para verificar que todo este de manera correcta.
plt.plot(df["AoA"], df["Cl"])
plt.title("Curca de sustentacion vs AoA")
plt.xlabel('AoA')
plt.grid()
plt.ylabel('cl')
plt.show()


#Obtener el modelo lineal de la curva de -5 a 5 grados

df["Rad_AoA"]=np.radians(df["AoA"])

#Guardamos la informacion en una lista de AoA y los cl
AoA=df["AoA"].tolist()

AoA_inf=AoA.index(-5.0)
AoA_sup=AoA.index(5.0)

#Solo agregar los datos de -5 a 5 de los data frame a las listas

Rad_AoA = df['Rad_AoA'].iloc[AoA_inf: AoA_sup].values.tolist()
cl_list=df['Cl'].iloc[AoA_inf: AoA_sup].values.tolist()

#Mandamos los arreglos a la regresion lineal

lineal=regresion(Rad_AoA,cl_list)

#Obtenemos el valor de cl0 y la pendiente de la aproximacion.
cl0=lineal[1]
m_Polar=lineal[0]


#Calculo de valor de nula sustentacion

alpha_L0=-1*(cl0)/m_Polar


#__________________________________________________________
#             Solucion de ala recta
#__________________________________________________________

#Definicon de los datos de la simulacion

###################    Datos de entrada ###################################
#____________________________________________________________________________
v_inf= 600*(1000)*(1/3600)    #m/s
c=1                           #m
b=6                           #m
rho0=1.2                      #Kg/m3
alpha_ini=10                  #grados

#Numero de nodos
Nx=151

#Calculos de la discretizacion

dx=(180/Nx)

#_____________________________________________________________________________

#Guardamos la discretizacion de los angulos en una lista
for i in range(1,Nx):
  phi.append(dx*i)


#Angulos de la discretizacion en radianes
phi_rad=[math.radians(angulo) for angulo in phi]

#Obtenemos la matriz
n=len(phi)

Fij(b,c,n,m_Polar,phi_rad,ai)

#Trnsponemos la matriz de coeficientes obtenida.

ai_transpose = [[ai[j][i] for j in range(n)] for i in range(n)]

#asignamos a un arrray los datos de la lista
MatrizCoef=np.array(ai_transpose)

#Invertimos la transpuesta de la matriz
Inv_ai_transpose=np.linalg.inv(MatrizCoef)

#Comprobamos el resultado

resultado = np.matmul(Inv_ai_transpose, MatrizCoef)

#Vector de terminos independientes

for i in range(1,n+1):
  V_ind.append(1)

aj = np.matmul(Inv_ai_transpose, V_ind)

#Damos el umbral para que los datos se vueelvan cero
umbral = 1e-15

# Reemplazar valores peque√±os por cero
aj[aj < umbral] = 0.0


#Pasamos dato de entrada a radianes
alpha_ini_rad=math.radians(alpha_ini)

#Valores de los coeficientes Aj
for i in aj:
  Aj.append(i*(alpha_ini_rad-alpha_L0))



#Distribucion de sustentacion
for i in range(n):
  aux2=0.0
  for j in range(n):
    aux2=2*rho0*((v_inf)**2)*b*Aj[j]*math.sin((j+1)*phi_rad[i])+aux2

  L_distribution.append(aux2)

#Lista para guardar los valores eespecificos del calculo

for i in phi_rad:

  val=(b/2)*math.cos(i)
  Env_dis.append(val)


#Ploteamos la curva solo para verificar que todo este de manera correcta.
plt.plot(Env_dis, L_distribution)
plt.title("Distribucion de sustentacion")
plt.xlabel('Envergadura')
plt.grid()
plt.ylabel('Lift')
plt.show()


print(L_distribution)

